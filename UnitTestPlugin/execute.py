#! /usr/bin/env python

#-----------------------------------------
# unit_test.py 
# Version Number: 1.0.0 
# Last Revision: 8/28/2012 
# by James DeFilippo with Mark Sherman  
# as part of a project under the supervision of Professor Fred Martin and Professor Sarita Bassil
#-----------------------------------------

import os
import sys 
from subprocess import call 
import StringIO 
import ConfigParser
import glob
import shutil 
import re
from subprocess import check_call
from decimal import * 

DEBUG = 0

stdout_output = " " 

#Assignments come in the form 'px' where x is some number. The function extracts x from the compound expression.
def get_assignment_Number ( assignment ): 
    # Transforms p as a regular expression into an object that represents a regular expression.
    p = re.compile( 'p' )
    # Substitute '' for any instance of the regular expression found in assignment.
    assignment_Number = p.sub('', assignment)
    # Make sure assignment_Number is a string.
    assignment_Number = str(assignment_Number)
    return assignment_Number

# A sectionless configuration file is passed to WebCAT as the second argument to the command line. ConfigParser can only read configuration files with section headers. To get aroudn this problem, the configuration is read in as a string with an arbitrary section header prepended to it.
initial_string = '[section]\n' + open(sys.argv[1], 'r').read()
# The string is transformed into a string buffer which serves as a file-like object.
initial_filepointer = StringIO.StringIO(initial_string) 
# A raw config parser object of class ConfigParser is initialized under the name of config. 
config = ConfigParser.RawConfigParser()
# The config parser object is fed the string-buffer. 
config.readfp(initial_filepointer)

# Read in relevant values from the WebCAT configuration file.
assignment = config.get('section', 'assignment')
user_Name = config.get('section', 'userName')
result_Dir = config.get('section', 'resultDir')
working_Dir = config.get('section', 'workingDir')
script_Home = config.get('section', 'scriptHome')
max_score_correctness = config.get('section', 'max.score.correctness')
# Extract assignment number from the assignment of form p[number]
assignment_Number = get_assignment_Number ( assignment )


os.chdir(script_Home + "/" + assignment) 
shutil.copy('configuration.py', working_Dir)
os.chdir(script_Home)
shutil.copy('minunit.h', working_Dir)
os.chdir(working_Dir)
import configuration

destination_file = open("destinationfile.c", "w")
destination_file = open("destinationfile.c", "r+")
source_file = open(assignment + ".c", "r") 

destination_file.write('#include "minunit.h"\n')

# Prevent duplicate mains (see below). 
for line in source_file: 
    line = line.replace('main', 'student_main')
    destination_file.write(line)


count = 0 
for functions, arguments, return_values, messages in configuration.tests: 
    count = count + 1
    destination_file.write('static char * test' + str(count) + '() {\ntests_run++;\n')
    destination_file.write('mu_assert(\"') 
    destination_file.write(messages)
    destination_file.write('\", ')
    destination_file.write(functions)
    destination_file.write('(' + arguments + ') == ' + return_values + ');')
    destination_file.write('\ntests_passed++;')
    destination_file.write('\nreturn 0;}\n')
    destination_file.write('static char * run_test' + str(count) + '() { \n mu_run_test(test' + str(count) + '); \n return 0; }\n') 

destination_file.write('int main() {\n FILE * fin; \n')
for x in range(count): 
     y = x + 1
     destination_file.write('run_test')
     destination_file.write(str(y))
     destination_file.write('();\n\n')
destination_file.write('printf("You passed %d out of %d tests run.\\n", tests_passed, tests_run);\n')
destination_file.write('\n\nfin = fopen("log.txt", "w+");\n\n')
destination_file.write('fprintf(fin, "[section]\\ncount_pass = %d\\ncount = %d", tests_passed, tests_run);\n')
destination_file.write('fclose(fin);\n')
destination_file.write('return 0;\n}')

# Failure to close destination file will result in compilation errors. Closing all opened files is an obvious best practice.
destination_file.close()
source_file.close() 

# Compile the new destination file which includes all the students code as well as the unit test framework.
compile_command = configuration.compile_command 
call(compile_command, shell=True)

# Execute the program and send the output to some file specified in configuration.py
execute_command = configuration.execute_command
call(execute_command, shell=True)

output_file = configuration.output_file 
# Open the file which contains output and read its contents into the current script in string form.
destination_file_output = open(output_file, "r")
destination_file_output_string = destination_file_output.read() 


# Open a config files which contains scores generated by the Unit Test Module. 
log = ConfigParser.RawConfigParser()
log.read('log.txt')
count_pass = log.get('section', 'count_pass')
count = log.get('section', 'count')

# Convert integer scores to floating-point numbers to prevent unnecessary truncation. 
count_pass = Decimal(count_pass)
count = Decimal(count)
max_score_correctness = Decimal(max_score_correctness)

if (count != 0): 
    score_correctness = (count_pass / count) * max_score_correctness
else: 
    score_correctness = 0

# compile log is read as a report file. It contains the results of the unit tests. WebCAT will create a special box for this. 
compile_log = result_Dir + "/" + "compile.log"
compile_log_handle = open(compile_log, 'w') 
compile_log_handle = open(compile_log, 'r+')
compile_log_handle.write('<div class="shadow"><table><tbody>\n') 
compile_log_handle.write('<tr><th>\n')
compile_log_handle.write('Feedback</th></tr>\n')
compile_log_handle.write('<tr><td><pre>\n')
compile_log_handle.write(destination_file_output_string)
compile_log_handle.write('</pre></td></tr></tbody></table></div><div class="spacer">&nbsp;</div>')

config_file = open(sys.argv[1]).read()
# Specify the number of reports (feedback boxes) WebCAT will need to display. 
config_file = config_file.replace('numReports=0', 'numReports=1')
# Open the configuration file in the command line for writing. (WebCAT will save your changes in a grading.properties file.) 
config_file_write = open(sys.argv[1], 'w')
config_file_write.write(config_file)
config_file_write.close()


# Other essential data needed to run the plugin. 
config_file = open(sys.argv[1], 'a+b').write('disableCodeCoverage=1\nexec.timeout=6000\nreport1.file=compile.log\nreport1.mimeType=text/html\nnumCodeMarkups=0\nscore.correctness=')
config_file = open(sys.argv[1], 'a+b').write(str(score_correctness))
config_file = open(sys.argv[1], 'a+b').write('\nscore.tools=0')

destination_file_output.close()
compile_log_handle.close()
